<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" encoding="us-ascii" #>
<#
// Note: We specify ASCII as output encoding above to prevent different UTF-8 BOM behavior with VS and dotnet-t4.
#>
// <auto-generated>
// This file is autogenerated from a T4 text template. Do not modify it directly.
// To generate the file outside from Visual Studio, install and run dotnet-t4:
//
//     dotnet tool install --global dotnet-t4 --version 2.3.0
//     t4 src/Linker.DefineFunction.tt -o src/Linker.DefineFunction.cs
//
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;

namespace Wasmtime
{
    public partial class Linker
    {
<#
// Generate overloads for different combinations of function parameter count, result count,
// and hasCaller states.
// Currently, we generate them for a maximum of 12 parameters and 4 result values, which means there
// will be 2 * 13 * 5 = 130 overloads of DefineFunction accepting an Action/Func.
// Note that more than 200 overloads can cause the C# compiler to no longer resolve the overloads
// correctly (tested with Visual Studio 17.4.0 Preview 2.1).
// For delegate types not covered by these overloads, we have a method accepting a Delegate which
// will be called using reflection.
const int maxParameterCount = 12;
const int maxReturnCount = 4;

for (int hasCaller = 0; hasCaller < 2; hasCaller++)
{
    for (int resultCount = 0; resultCount <= maxReturnCount; resultCount++)
    {
        for (int parameterCount = 0; parameterCount <= maxParameterCount; parameterCount++)
        {
            var methodGenerics = new StringBuilder();
            var delegateType = new StringBuilder(resultCount == 0 ? "Action" : "Func");
            var parameterConverters = new StringBuilder();
    
            if (parameterCount > 0 || resultCount > 0)
            {
                methodGenerics.Append('<');
            }

            if (parameterCount > 0 || resultCount > 0 || hasCaller > 0)
            {
                delegateType.Append('<');
            }

            if (hasCaller > 0)
            {
                delegateType.Append("Caller");

                if (parameterCount + resultCount > 0)
                {
                    delegateType.Append(", ");
                }
            }

            for (int x = 0; x < parameterCount; x++)
            {
                if (x > 0)
                {
                    methodGenerics.Append(", ");
                }

                if (x > 0)
                {
                    delegateType.Append(", ");
                }

                string genericType = "T";
                if (parameterCount > 1)
                {
                    genericType += (x + 1).ToString(CultureInfo.InvariantCulture);
                }

                methodGenerics.Append(genericType);
                delegateType.Append(genericType);

                parameterConverters.AppendLine($"            var conv{genericType} = ValueBox.Converter<{genericType}>();");
            }

            if (parameterCount > 0 && resultCount > 0)
            {
                methodGenerics.Append(", ");
            }

            if (parameterCount > 0 && resultCount > 0)
            {
                delegateType.Append(", ");
            }

            if (resultCount > 1)
            {
                delegateType.Append("ValueTuple<");
            }

            for (int x = 0; x < resultCount; x++)
            {
                if (x > 0)
                {
                    methodGenerics.Append(", ");
                    delegateType.Append(", ");
                }

                string genericType = "TResult";
                if (resultCount > 1)
                {
                    genericType += (x + 1).ToString(CultureInfo.InvariantCulture);
                }

                methodGenerics.Append(genericType);
                delegateType.Append(genericType);

                parameterConverters.AppendLine($"            var conv{genericType} = ValueBox.Converter<{genericType}>();");
            }

            if (resultCount > 1)
            {
                delegateType.Append(">");
            }

            if (parameterCount > 0 || resultCount > 0)
            {
                methodGenerics.Append('>');
            }

            if (parameterCount > 0 || resultCount > 0 || hasCaller > 0)
            {
                delegateType.Append(">");
            }
#>
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<#= methodGenerics #>(string module, string name, <#= delegateType #> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, out var hasCaller);

            if (hasCaller != <#= (hasCaller > 0) ? "true" : "false" #>)
            {
                // TODO: Free the ValueKind memory, or provide a way for GetFunctionType to do these checks
                // before allocating the ValueKind memory.
                throw new ArgumentException("Use a different overload that implicitly supplies Caller."); 
            }

            // TODO: Once PR #161 is merged, uncomment this
            //if (returnsTuple != <#= (resultCount > 1) ? "true" : "false" #>)
            //{
            //    // TODO: Free the ValueKind memory, or provide a way for GetFunctionType to do these checks
            //    // before allocating the ValueKind memory.
            //    throw new ArgumentException("Use a different overload that implicitly returns ValueTuple.");
            //}

<#= parameterConverters
#>
            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        <#= resultCount > 0 ? "var result = " : "" #>callback(
                            <#
                if (hasCaller > 0)
                {
                    #>caller<#

                    if (parameterCount > 0)
                    {
                        #>,
                            <#
                    }
                }

                for (int i = 0; i < parameterCount; i++)
                {
                    string genericType = "T";
                    if (parameterCount > 1)
                    {
                        genericType += (i + 1).ToString(CultureInfo.InvariantCulture);
                    }

                    #>conv<#= genericType #>.Unbox(caller, args[<#= i.ToString(CultureInfo.InvariantCulture) #>].ToValueBox())<#

                    if (i + 1 < parameterCount)
                    {
                    #>,
                            <#
                    }
                }
                #>);

                        <#
                for (int i = 0; i < resultCount; i++)
                {
                    string genericType = "TResult";
                    if (resultCount > 1)
                    {
                        genericType += (i + 1).ToString(CultureInfo.InvariantCulture);
                    }

                    string tupleAccessor = "";
                    if (resultCount > 1)
                    {
                        tupleAccessor = ".Item" + (i + 1).ToString(CultureInfo.InvariantCulture);
                    }

                    #>results[<#= i.ToString(CultureInfo.InvariantCulture) #>] = Value.FromValueBox(conv<#= genericType #>.Box(result<#= tupleAccessor #>));
                        <#
                }
                #>

                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
<#
        }
    }
}
#>
    }
}