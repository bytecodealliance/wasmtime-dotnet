<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" encoding="us-ascii" #>
<#@ include file="FunctionCallbackOverloadTemplates.t4" once="true" #>
<#
// Note: We specify ASCII as output encoding above to prevent different UTF-8 BOM behavior with VS and dotnet-t4.
#>
// <auto-generated>
// This file is automatically generated from a T4 text template (Linker.DefineFunction.tt)
// when building the project.
// Do not modify it directly.
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;

namespace Wasmtime
{
    public partial class Linker
    {
<#
foreach (var (hasCaller, resultCount, parameterCount, methodGenerics, delegateType, callbackParameterTypeExpressions, callbackReturnTypeExpression, parameterConverters) in EnumerateTypeCombinations())
{
#>
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<#= methodGenerics #>(string module, string name, <#= delegateType #> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            var callbackParameterTypes = new Type[] { <#= callbackParameterTypeExpressions #>};
            var callbackReturnType = <#= callbackReturnTypeExpression #>;

            using var funcType = Function.GetFunctionType(callbackParameterTypes, callbackReturnType, parameterKinds, resultKinds, allowCaller: <#= hasCaller ? "true" : "false" #>, allowTuple: <#= (resultCount > 1) ? "true" : "false" #>, out _, out _);

            if (funcType is null)
            {
                // This means a parameter/result type combination was used that cannot
                // be represented with the current generic parameters. Therefore, fall
                // back to using reflection.
                DefineFunction(module, name, (Delegate)callback);
                return;
            }

<#= parameterConverters
#>
            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
<# GenerateCallbackContent(hasCaller, resultCount, parameterCount); #>
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
<#
}
#>
    }
}