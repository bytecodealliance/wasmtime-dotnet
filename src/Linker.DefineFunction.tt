<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" encoding="us-ascii" #>
<#@ include file="FunctionCallbackOverloadTemplates.t4" once="true" #>
<#
// Note: We specify ASCII as output encoding above to prevent different UTF-8 BOM behavior with VS and dotnet-t4.
#>
// <auto-generated>
// This file is automatically generated from a T4 text template (Linker.DefineFunction.tt)
// when building the project.
// Do not modify it directly.
// </auto-generated>

#nullable enable

using System;
using System.Buffers;
using System.Runtime.InteropServices;
using System.Text;

namespace Wasmtime
{
    public partial class Linker
    {
<#
// Generate overloads for different combinations of function parameter count, result count,
// and hasCaller states.
// Currently, we generate them for a maximum of 12 parameters and 4 result values, which means there
// will be 2 * 13 * 5 = 130 overloads of DefineFunction accepting an Action/Func.
// Note that more than 200 overloads can cause the C# compiler to no longer resolve the overloads
// correctly (tested with Visual Studio 17.4.0 Preview 2.1).
// For delegate types not covered by these overloads, users will need to use an untyped callback.
foreach (var (hasCaller, resultCount, parameterCount, methodGenerics, delegateType, callbackParameterTypeExpressions, callbackReturnTypeExpression, parameterConverters, resultConverters) in EnumerateTypeCombinations())
{
#>
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<#= methodGenerics #>(string module, string name, <#= delegateType #> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(<# if (callbackParameterTypeExpressions.Length == 0) { #>Array.Empty<Type>()<# } else { #>new Type[] { <#= callbackParameterTypeExpressions #>}<# } #>, <#= callbackReturnTypeExpression #>, allowCaller: <#= hasCaller ? "true" : "false" #>, allowTuple: true);
<#= parameterConverters
#><#= resultConverters
#>
            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
<# GenerateCallbackContent(hasCaller, resultCount, parameterCount, false); #>
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

<#
}
#>
    }
}