// <auto-generated>
// This file is automatically generated from a T4 text template (Function.Wrap.tt)
// when building the project.
// Do not modify it directly.
// </auto-generated>

#nullable enable

using System;

namespace Wasmtime
{
    public partial class Function
    {
        private object? _wrapperCache;

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action? WrapAction()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = Array.Empty<Type>();
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(0, Results.Count);

            Action result = () =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;


                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T>? WrapAction<T>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT = ValueRaw.Converter<T>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(1, Results.Count);

            Action<T> result = (p0) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT.Box(storeContext, store, ref argsAndResults[0], p0);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2>? WrapAction<T1, T2>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(2, Results.Count);

            Action<T1, T2> result = (p0, p1) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3>? WrapAction<T1, T2, T3>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(3, Results.Count);

            Action<T1, T2, T3> result = (p0, p1, p2) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4>? WrapAction<T1, T2, T3, T4>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(4, Results.Count);

            Action<T1, T2, T3, T4> result = (p0, p1, p2, p3) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5>? WrapAction<T1, T2, T3, T4, T5>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(5, Results.Count);

            Action<T1, T2, T3, T4, T5> result = (p0, p1, p2, p3, p4) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5, T6>? WrapAction<T1, T2, T3, T4, T5, T6>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5, T6> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(6, Results.Count);

            Action<T1, T2, T3, T4, T5, T6> result = (p0, p1, p2, p3, p4, p5) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5, T6, T7>? WrapAction<T1, T2, T3, T4, T5, T6, T7>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5, T6, T7> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(7, Results.Count);

            Action<T1, T2, T3, T4, T5, T6, T7> result = (p0, p1, p2, p3, p4, p5, p6) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5, T6, T7, T8>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5, T6, T7, T8> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(8, Results.Count);

            Action<T1, T2, T3, T4, T5, T6, T7, T8> result = (p0, p1, p2, p3, p4, p5, p6, p7) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5, T6, T7, T8, T9>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5, T6, T7, T8, T9> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(9, Results.Count);

            Action<T1, T2, T3, T4, T5, T6, T7, T8, T9> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(10, Results.Count);

            Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(11, Results.Count);

            Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(12, Results.Count);

            Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);
                convT12.Box(storeContext, store, ref argsAndResults[11], p11);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convT13 = ValueRaw.Converter<T13>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(13, Results.Count);

            Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);
                convT12.Box(storeContext, store, ref argsAndResults[11], p11);
                convT13.Box(storeContext, store, ref argsAndResults[12], p12);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convT13 = ValueRaw.Converter<T13>();
            var convT14 = ValueRaw.Converter<T14>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(14, Results.Count);

            Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);
                convT12.Box(storeContext, store, ref argsAndResults[11], p11);
                convT13.Box(storeContext, store, ref argsAndResults[12], p12);
                convT14.Box(storeContext, store, ref argsAndResults[13], p13);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convT13 = ValueRaw.Converter<T13>();
            var convT14 = ValueRaw.Converter<T14>();
            var convT15 = ValueRaw.Converter<T15>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(15, Results.Count);

            Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);
                convT12.Box(storeContext, store, ref argsAndResults[11], p11);
                convT13.Box(storeContext, store, ref argsAndResults[12], p12);
                convT14.Box(storeContext, store, ref argsAndResults[13], p13);
                convT15.Box(storeContext, store, ref argsAndResults[14], p14);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convT13 = ValueRaw.Converter<T13>();
            var convT14 = ValueRaw.Converter<T14>();
            var convT15 = ValueRaw.Converter<T15>();
            var convT16 = ValueRaw.Converter<T16>();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(16, Results.Count);

            Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);
                convT12.Box(storeContext, store, ref argsAndResults[11], p11);
                convT13.Box(storeContext, store, ref argsAndResults[12], p12);
                convT14.Box(storeContext, store, ref argsAndResults[13], p13);
                convT15.Box(storeContext, store, ref argsAndResults[14], p14);
                convT16.Box(storeContext, store, ref argsAndResults[15], p15);

                InvokeWithoutReturn(argsAndResults, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<TResult?>? WrapFunc<TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = Array.Empty<Type>();
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(0, Results.Count);

            Func<TResult?> result = () =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;


                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T, TResult?>? WrapFunc<T, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT = ValueRaw.Converter<T>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(1, Results.Count);

            Func<T, TResult?> result = (p0) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT.Box(storeContext, store, ref argsAndResults[0], p0);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, TResult?>? WrapFunc<T1, T2, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(2, Results.Count);

            Func<T1, T2, TResult?> result = (p0, p1) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, TResult?>? WrapFunc<T1, T2, T3, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(3, Results.Count);

            Func<T1, T2, T3, TResult?> result = (p0, p1, p2) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, TResult?>? WrapFunc<T1, T2, T3, T4, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(4, Results.Count);

            Func<T1, T2, T3, T4, TResult?> result = (p0, p1, p2, p3) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, TResult?>? WrapFunc<T1, T2, T3, T4, T5, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(5, Results.Count);

            Func<T1, T2, T3, T4, T5, TResult?> result = (p0, p1, p2, p3, p4) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, T6, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, T6, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(6, Results.Count);

            Func<T1, T2, T3, T4, T5, T6, TResult?> result = (p0, p1, p2, p3, p4, p5) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, T6, T7, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, T6, T7, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(7, Results.Count);

            Func<T1, T2, T3, T4, T5, T6, T7, TResult?> result = (p0, p1, p2, p3, p4, p5, p6) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(8, Results.Count);

            Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(9, Results.Count);

            Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(10, Results.Count);

            Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(11, Results.Count);

            Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(12, Results.Count);

            Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);
                convT12.Box(storeContext, store, ref argsAndResults[11], p11);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convT13 = ValueRaw.Converter<T13>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(13, Results.Count);

            Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);
                convT12.Box(storeContext, store, ref argsAndResults[11], p11);
                convT13.Box(storeContext, store, ref argsAndResults[12], p12);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convT13 = ValueRaw.Converter<T13>();
            var convT14 = ValueRaw.Converter<T14>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(14, Results.Count);

            Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);
                convT12.Box(storeContext, store, ref argsAndResults[11], p11);
                convT13.Box(storeContext, store, ref argsAndResults[12], p12);
                convT14.Box(storeContext, store, ref argsAndResults[13], p13);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convT13 = ValueRaw.Converter<T13>();
            var convT14 = ValueRaw.Converter<T14>();
            var convT15 = ValueRaw.Converter<T15>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(15, Results.Count);

            Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);
                convT12.Box(storeContext, store, ref argsAndResults[11], p11);
                convT13.Box(storeContext, store, ref argsAndResults[12], p12);
                convT14.Box(storeContext, store, ref argsAndResults[13], p13);
                convT15.Box(storeContext, store, ref argsAndResults[14], p14);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache is Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult?> cached)
            {
                return cached;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), typeof(T13), typeof(T14), typeof(T15), typeof(T16), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convT13 = ValueRaw.Converter<T13>();
            var convT14 = ValueRaw.Converter<T14>();
            var convT15 = ValueRaw.Converter<T15>();
            var convT16 = ValueRaw.Converter<T16>();

            // Create a factory for the return type
            var factory = IReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = Math.Max(16, Results.Count);

            Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15) =>
            {
                // Allocate space for both the arguments and the results.
                Span<ValueRaw> argsAndResults = stackalloc ValueRaw[allocCount];
                var storeContext = store.Context;

                convT1.Box(storeContext, store, ref argsAndResults[0], p0);
                convT2.Box(storeContext, store, ref argsAndResults[1], p1);
                convT3.Box(storeContext, store, ref argsAndResults[2], p2);
                convT4.Box(storeContext, store, ref argsAndResults[3], p3);
                convT5.Box(storeContext, store, ref argsAndResults[4], p4);
                convT6.Box(storeContext, store, ref argsAndResults[5], p5);
                convT7.Box(storeContext, store, ref argsAndResults[6], p6);
                convT8.Box(storeContext, store, ref argsAndResults[7], p7);
                convT9.Box(storeContext, store, ref argsAndResults[8], p8);
                convT10.Box(storeContext, store, ref argsAndResults[9], p9);
                convT11.Box(storeContext, store, ref argsAndResults[10], p10);
                convT12.Box(storeContext, store, ref argsAndResults[11], p11);
                convT13.Box(storeContext, store, ref argsAndResults[12], p12);
                convT14.Box(storeContext, store, ref argsAndResults[13], p13);
                convT15.Box(storeContext, store, ref argsAndResults[14], p14);
                convT16.Box(storeContext, store, ref argsAndResults[15], p15);

                return InvokeWithReturn(argsAndResults, factory, storeContext);
            };

            _wrapperCache = result;
            return result;
        }

    }
}