// <auto-generated>
// This file is automatically generated from a T4 text template (Function.Wrap.tt)
// when building the project.
// Do not modify it directly.
// </auto-generated>

#nullable enable

using System;
using System.Buffers;

namespace Wasmtime
{
    public partial class AsyncFunction
    {
        private object? _wrapperCache;

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction? WrapAction()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction))
            {
                return (AsyncAction)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = Array.Empty<Type>();
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it

            // Determine how much space to allocate for params/results
            var allocCount = 0 + Results.Count;

            AsyncAction result = () =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T>? WrapAction<T>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T>))
            {
                return (AsyncAction<T>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT = ValueBox.Converter<T>();

            // Determine how much space to allocate for params/results
            var allocCount = 1 + Results.Count;

            AsyncAction<T> result = (p0) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT.Box(p0)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T1, T2>? WrapAction<T1, T2>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T1, T2>))
            {
                return (AsyncAction<T1, T2>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();

            // Determine how much space to allocate for params/results
            var allocCount = 2 + Results.Count;

            AsyncAction<T1, T2> result = (p0, p1) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T1, T2, T3>? WrapAction<T1, T2, T3>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T1, T2, T3>))
            {
                return (AsyncAction<T1, T2, T3>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();

            // Determine how much space to allocate for params/results
            var allocCount = 3 + Results.Count;

            AsyncAction<T1, T2, T3> result = (p0, p1, p2) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T1, T2, T3, T4>? WrapAction<T1, T2, T3, T4>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T1, T2, T3, T4>))
            {
                return (AsyncAction<T1, T2, T3, T4>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();

            // Determine how much space to allocate for params/results
            var allocCount = 4 + Results.Count;

            AsyncAction<T1, T2, T3, T4> result = (p0, p1, p2, p3) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T1, T2, T3, T4, T5>? WrapAction<T1, T2, T3, T4, T5>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T1, T2, T3, T4, T5>))
            {
                return (AsyncAction<T1, T2, T3, T4, T5>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();

            // Determine how much space to allocate for params/results
            var allocCount = 5 + Results.Count;

            AsyncAction<T1, T2, T3, T4, T5> result = (p0, p1, p2, p3, p4) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T1, T2, T3, T4, T5, T6>? WrapAction<T1, T2, T3, T4, T5, T6>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T1, T2, T3, T4, T5, T6>))
            {
                return (AsyncAction<T1, T2, T3, T4, T5, T6>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();

            // Determine how much space to allocate for params/results
            var allocCount = 6 + Results.Count;

            AsyncAction<T1, T2, T3, T4, T5, T6> result = (p0, p1, p2, p3, p4, p5) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T1, T2, T3, T4, T5, T6, T7>? WrapAction<T1, T2, T3, T4, T5, T6, T7>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T1, T2, T3, T4, T5, T6, T7>))
            {
                return (AsyncAction<T1, T2, T3, T4, T5, T6, T7>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();

            // Determine how much space to allocate for params/results
            var allocCount = 7 + Results.Count;

            AsyncAction<T1, T2, T3, T4, T5, T6, T7> result = (p0, p1, p2, p3, p4, p5, p6) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8>))
            {
                return (AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();

            // Determine how much space to allocate for params/results
            var allocCount = 8 + Results.Count;

            AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8> result = (p0, p1, p2, p3, p4, p5, p6, p7) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    argsAndResults[7] = Value.FromValueBox(
                        convT8.Box(p7)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9>))
            {
                return (AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();

            // Determine how much space to allocate for params/results
            var allocCount = 9 + Results.Count;

            AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    argsAndResults[7] = Value.FromValueBox(
                        convT8.Box(p7)
                    );
                    argsAndResults[8] = Value.FromValueBox(
                        convT9.Box(p8)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>))
            {
                return (AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();

            // Determine how much space to allocate for params/results
            var allocCount = 10 + Results.Count;

            AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    argsAndResults[7] = Value.FromValueBox(
                        convT8.Box(p7)
                    );
                    argsAndResults[8] = Value.FromValueBox(
                        convT9.Box(p8)
                    );
                    argsAndResults[9] = Value.FromValueBox(
                        convT10.Box(p9)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>))
            {
                return (AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();

            // Determine how much space to allocate for params/results
            var allocCount = 11 + Results.Count;

            AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    argsAndResults[7] = Value.FromValueBox(
                        convT8.Box(p7)
                    );
                    argsAndResults[8] = Value.FromValueBox(
                        convT9.Box(p8)
                    );
                    argsAndResults[9] = Value.FromValueBox(
                        convT10.Box(p9)
                    );
                    argsAndResults[10] = Value.FromValueBox(
                        convT11.Box(p10)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as an <c>Action</c>. Wrapped <c>Action</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Action</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>? WrapAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>))
            {
                return (AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(default(Type), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();

            // Determine how much space to allocate for params/results
            var allocCount = 12 + Results.Count;

            AsyncAction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    argsAndResults[7] = Value.FromValueBox(
                        convT8.Box(p7)
                    );
                    argsAndResults[8] = Value.FromValueBox(
                        convT9.Box(p8)
                    );
                    argsAndResults[9] = Value.FromValueBox(
                        convT10.Box(p9)
                    );
                    argsAndResults[10] = Value.FromValueBox(
                        convT11.Box(p10)
                    );
                    argsAndResults[11] = Value.FromValueBox(
                        convT12.Box(p11)
                    );
                    return InvokeWithoutReturn(argsAndResults);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<TResult?>? WrapFunc<TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<TResult?>))
            {
                return (AsyncFunc<TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = Array.Empty<Type>();
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 0 + Results.Count;

            AsyncFunc<TResult?> result = () =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T, TResult?>? WrapFunc<T, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T, TResult?>))
            {
                return (AsyncFunc<T, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT = ValueBox.Converter<T>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 1 + Results.Count;

            AsyncFunc<T, TResult?> result = (p0) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT.Box(p0)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T1, T2, TResult?>? WrapFunc<T1, T2, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T1, T2, TResult?>))
            {
                return (AsyncFunc<T1, T2, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 2 + Results.Count;

            AsyncFunc<T1, T2, TResult?> result = (p0, p1) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T1, T2, T3, TResult?>? WrapFunc<T1, T2, T3, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T1, T2, T3, TResult?>))
            {
                return (AsyncFunc<T1, T2, T3, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 3 + Results.Count;

            AsyncFunc<T1, T2, T3, TResult?> result = (p0, p1, p2) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T1, T2, T3, T4, TResult?>? WrapFunc<T1, T2, T3, T4, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T1, T2, T3, T4, TResult?>))
            {
                return (AsyncFunc<T1, T2, T3, T4, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 4 + Results.Count;

            AsyncFunc<T1, T2, T3, T4, TResult?> result = (p0, p1, p2, p3) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T1, T2, T3, T4, T5, TResult?>? WrapFunc<T1, T2, T3, T4, T5, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T1, T2, T3, T4, T5, TResult?>))
            {
                return (AsyncFunc<T1, T2, T3, T4, T5, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 5 + Results.Count;

            AsyncFunc<T1, T2, T3, T4, T5, TResult?> result = (p0, p1, p2, p3, p4) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T1, T2, T3, T4, T5, T6, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T1, T2, T3, T4, T5, T6, TResult?>))
            {
                return (AsyncFunc<T1, T2, T3, T4, T5, T6, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 6 + Results.Count;

            AsyncFunc<T1, T2, T3, T4, T5, T6, TResult?> result = (p0, p1, p2, p3, p4, p5) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T1, T2, T3, T4, T5, T6, T7, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T1, T2, T3, T4, T5, T6, T7, TResult?>))
            {
                return (AsyncFunc<T1, T2, T3, T4, T5, T6, T7, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 7 + Results.Count;

            AsyncFunc<T1, T2, T3, T4, T5, T6, T7, TResult?> result = (p0, p1, p2, p3, p4, p5, p6) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, TResult?>))
            {
                return (AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 8 + Results.Count;

            AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    argsAndResults[7] = Value.FromValueBox(
                        convT8.Box(p7)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult?>))
            {
                return (AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 9 + Results.Count;

            AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    argsAndResults[7] = Value.FromValueBox(
                        convT8.Box(p7)
                    );
                    argsAndResults[8] = Value.FromValueBox(
                        convT9.Box(p8)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult?>))
            {
                return (AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 10 + Results.Count;

            AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    argsAndResults[7] = Value.FromValueBox(
                        convT8.Box(p7)
                    );
                    argsAndResults[8] = Value.FromValueBox(
                        convT9.Box(p8)
                    );
                    argsAndResults[9] = Value.FromValueBox(
                        convT10.Box(p9)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult?>))
            {
                return (AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 11 + Results.Count;

            AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    argsAndResults[7] = Value.FromValueBox(
                        convT8.Box(p7)
                    );
                    argsAndResults[8] = Value.FromValueBox(
                        convT9.Box(p8)
                    );
                    argsAndResults[9] = Value.FromValueBox(
                        convT10.Box(p9)
                    );
                    argsAndResults[10] = Value.FromValueBox(
                        convT11.Box(p10)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

        /// <summary>
        /// Attempt to wrap this function as a <c>Func</c>. Wrapped <c>Func</c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c>Func</c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult?>? WrapFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult?>))
            {
                return (AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult?>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            var parameterTypes = new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), };
            
            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(typeof(TResult), parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();

            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

            // Determine how much space to allocate for params/results
            var allocCount = 12 + Results.Count;

            AsyncFunc<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult?> result = (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
                    argsAndResults[0] = Value.FromValueBox(
                        convT1.Box(p0)
                    );
                    argsAndResults[1] = Value.FromValueBox(
                        convT2.Box(p1)
                    );
                    argsAndResults[2] = Value.FromValueBox(
                        convT3.Box(p2)
                    );
                    argsAndResults[3] = Value.FromValueBox(
                        convT4.Box(p3)
                    );
                    argsAndResults[4] = Value.FromValueBox(
                        convT5.Box(p4)
                    );
                    argsAndResults[5] = Value.FromValueBox(
                        convT6.Box(p5)
                    );
                    argsAndResults[6] = Value.FromValueBox(
                        convT7.Box(p6)
                    );
                    argsAndResults[7] = Value.FromValueBox(
                        convT8.Box(p7)
                    );
                    argsAndResults[8] = Value.FromValueBox(
                        convT9.Box(p8)
                    );
                    argsAndResults[9] = Value.FromValueBox(
                        convT10.Box(p9)
                    );
                    argsAndResults[10] = Value.FromValueBox(
                        convT11.Box(p10)
                    );
                    argsAndResults[11] = Value.FromValueBox(
                        convT12.Box(p11)
                    );
                    return InvokeWithReturn(argsAndResults, factory);
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

    }
}


