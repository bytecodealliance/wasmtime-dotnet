// <auto-generated>
// This file is autogenerated from a T4 text template (Linker.DefineFunction.tt).
// Do not modify it directly.
// To generate the file outside from Visual Studio, install and run dotnet-t4:
//
//     dotnet tool install --global dotnet-t4 --version 2.3.0
//     t4 src/Linker.DefineFunction.tt -o src/Linker.DefineFunction.cs
//
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;

namespace Wasmtime
{
    public partial class Linker
    {
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction(string module, string name, Action callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);


            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            );

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T>(string module, string name, Action<T> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT = ValueBox.Converter<T>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT.Unbox(caller, args[0].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2>(string module, string name, Action<T1, T2> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3>(string module, string name, Action<T1, T2, T3> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4>(string module, string name, Action<T1, T2, T3, T4> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5>(string module, string name, Action<T1, T2, T3, T4, T5> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6>(string module, string name, Action<T1, T2, T3, T4, T5, T6> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7>(string module, string name, Action<T1, T2, T3, T4, T5, T6, T7> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8>(string module, string name, Action<T1, T2, T3, T4, T5, T6, T7, T8> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string module, string name, Action<T1, T2, T3, T4, T5, T6, T7, T8, T9> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string module, string name, Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string module, string name, Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string module, string name, Action<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()),
                            convT12.Unbox(caller, args[11].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult>(string module, string name, Func<TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            );

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult>(string module, string name, Func<T, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT = ValueBox.Converter<T>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT.Unbox(caller, args[0].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult>(string module, string name, Func<T1, T2, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult>(string module, string name, Func<T1, T2, T3, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult>(string module, string name, Func<T1, T2, T3, T4, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult>(string module, string name, Func<T1, T2, T3, T4, T5, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult>(string module, string name, Func<T1, T2, T3, T4, T5, T6, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()),
                            convT12.Unbox(caller, args[11].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2>(string module, string name, Func<ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            );

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2>(string module, string name, Func<T, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT = ValueBox.Converter<T>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT.Unbox(caller, args[0].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2>(string module, string name, Func<T1, T2, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2>(string module, string name, Func<T1, T2, T3, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2>(string module, string name, Func<T1, T2, T3, T4, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2>(string module, string name, Func<T1, T2, T3, T4, T5, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2>(string module, string name, Func<T1, T2, T3, T4, T5, T6, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()),
                            convT12.Unbox(caller, args[11].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2, TResult3>(string module, string name, Func<ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            );

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2, TResult3>(string module, string name, Func<T, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT = ValueBox.Converter<T>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT.Unbox(caller, args[0].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2, TResult3>(string module, string name, Func<T1, T2, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2, TResult3>(string module, string name, Func<T1, T2, T3, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2, TResult3>(string module, string name, Func<T1, T2, T3, T4, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2, TResult3>(string module, string name, Func<T1, T2, T3, T4, T5, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2, TResult3>(string module, string name, Func<T1, T2, T3, T4, T5, T6, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2, TResult3>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2, TResult3>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2, TResult3>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2, TResult3>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2, TResult3>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2, TResult3>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()),
                            convT12.Unbox(caller, args[11].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            );

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT = ValueBox.Converter<T>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT.Unbox(caller, args[0].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1, T2, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1, T2, T3, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1, T2, T3, T4, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1, T2, T3, T4, T5, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1, T2, T3, T4, T5, T6, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: false, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()),
                            convT12.Unbox(caller, args[11].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction(string module, string name, Action<Caller> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);


            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller);

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T>(string module, string name, Action<Caller, T> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT = ValueBox.Converter<T>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT.Unbox(caller, args[0].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2>(string module, string name, Action<Caller, T1, T2> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3>(string module, string name, Action<Caller, T1, T2, T3> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4>(string module, string name, Action<Caller, T1, T2, T3, T4> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5>(string module, string name, Action<Caller, T1, T2, T3, T4, T5> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6>(string module, string name, Action<Caller, T1, T2, T3, T4, T5, T6> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7>(string module, string name, Action<Caller, T1, T2, T3, T4, T5, T6, T7> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8>(string module, string name, Action<Caller, T1, T2, T3, T4, T5, T6, T7, T8> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string module, string name, Action<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string module, string name, Action<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string module, string name, Action<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string module, string name, Action<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()),
                            convT12.Unbox(caller, args[11].ToValueBox()));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult>(string module, string name, Func<Caller, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller);

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult>(string module, string name, Func<Caller, T, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT = ValueBox.Converter<T>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT.Unbox(caller, args[0].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult>(string module, string name, Func<Caller, T1, T2, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult>(string module, string name, Func<Caller, T1, T2, T3, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult>(string module, string name, Func<Caller, T1, T2, T3, T4, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: false, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();
            var convTResult = ValueBox.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()),
                            convT12.Unbox(caller, args[11].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult.Box(result));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2>(string module, string name, Func<Caller, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller);

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2>(string module, string name, Func<Caller, T, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT = ValueBox.Converter<T>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT.Unbox(caller, args[0].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2>(string module, string name, Func<Caller, T1, T2, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2>(string module, string name, Func<Caller, T1, T2, T3, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2>(string module, string name, Func<Caller, T1, T2, T3, T4, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()),
                            convT12.Unbox(caller, args[11].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2, TResult3>(string module, string name, Func<Caller, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller);

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT = ValueBox.Converter<T>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT.Unbox(caller, args[0].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T1, T2, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T1, T2, T3, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T1, T2, T3, T4, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2, TResult3>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()),
                            convT12.Unbox(caller, args[11].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller);

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT = ValueBox.Converter<T>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT.Unbox(caller, args[0].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T1, T2, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T1, T2, T3, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T1, T2, T3, T4, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<Caller, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            using var funcType = Function.GetFunctionType(callback.GetType(), parameterKinds, resultKinds, allowCaller: true, allowTuple: true, out _, out _);

            var convT1 = ValueBox.Converter<T1>();
            var convT2 = ValueBox.Converter<T2>();
            var convT3 = ValueBox.Converter<T3>();
            var convT4 = ValueBox.Converter<T4>();
            var convT5 = ValueBox.Converter<T5>();
            var convT6 = ValueBox.Converter<T6>();
            var convT7 = ValueBox.Converter<T7>();
            var convT8 = ValueBox.Converter<T8>();
            var convT9 = ValueBox.Converter<T9>();
            var convT10 = ValueBox.Converter<T10>();
            var convT11 = ValueBox.Converter<T11>();
            var convT12 = ValueBox.Converter<T12>();
            var convTResult1 = ValueBox.Converter<TResult1>();
            var convTResult2 = ValueBox.Converter<TResult2>();
            var convTResult3 = ValueBox.Converter<TResult3>();
            var convTResult4 = ValueBox.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncCallback func = (env, callerPtr, args, nargs, results, nresults) =>
                {
                    using var caller = new Caller(callerPtr);

                    try
                    {
                        var result = callback(
                            caller,
                            convT1.Unbox(caller, args[0].ToValueBox()),
                            convT2.Unbox(caller, args[1].ToValueBox()),
                            convT3.Unbox(caller, args[2].ToValueBox()),
                            convT4.Unbox(caller, args[3].ToValueBox()),
                            convT5.Unbox(caller, args[4].ToValueBox()),
                            convT6.Unbox(caller, args[5].ToValueBox()),
                            convT7.Unbox(caller, args[6].ToValueBox()),
                            convT8.Unbox(caller, args[7].ToValueBox()),
                            convT9.Unbox(caller, args[8].ToValueBox()),
                            convT10.Unbox(caller, args[9].ToValueBox()),
                            convT11.Unbox(caller, args[10].ToValueBox()),
                            convT12.Unbox(caller, args[11].ToValueBox()));

                        results[0] = Value.FromValueBox(convTResult1.Box(result.Item1));
                        results[1] = Value.FromValueBox(convTResult2.Box(result.Item2));
                        results[2] = Value.FromValueBox(convTResult3.Box(result.Item3));
                        results[3] = Value.FromValueBox(convTResult4.Box(result.Item4));
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        var bytes = Encoding.UTF8.GetBytes(ex.Message);

                        fixed (byte* ptr = bytes)
                        {
                            return Function.Native.wasmtime_trap_new(ptr, (UIntPtr)bytes.Length);
                        }
                    }
                };

                var moduleBytes = Encoding.UTF8.GetBytes(module);
                var nameBytes = Encoding.UTF8.GetBytes(name);
                fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                {
                    var error = Native.wasmtime_linker_define_func(
                        handle,
                        modulePtr,
                        (UIntPtr)moduleBytes.Length,
                        namePtr,
                        (UIntPtr)nameBytes.Length,
                        funcType,
                        func,
                        GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                        Function.Finalizer
                    );

                    if (error != IntPtr.Zero)
                    {
                        throw WasmtimeException.FromOwnedError(error);
                    }
                }
            }
        }
    }
}