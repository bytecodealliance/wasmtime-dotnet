// <auto-generated>
// This file is automatically generated from a T4 text template (Linker.DefineFunction.tt)
// when building the project.
// Do not modify it directly.
// </auto-generated>

#nullable enable

using System;
using System.Buffers;
using System.Runtime.InteropServices;
using System.Text;

namespace Wasmtime
{
    public partial class Linker
    {
        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction(string module, string name, Action callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(Array.Empty<Type>(), default(Type), allowCaller: false, allowTuple: true);

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            );

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T>(string module, string name, Action<T?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T), }, default(Type), allowCaller: false, allowTuple: true);
            var convT = ValueRaw.Converter<T>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT.Unbox(storeContext, store, args_and_results[0]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2>(string module, string name, Action<T1?, T2?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), }, default(Type), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3>(string module, string name, Action<T1?, T2?, T3?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), }, default(Type), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4>(string module, string name, Action<T1?, T2?, T3?, T4?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), }, default(Type), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5>(string module, string name, Action<T1?, T2?, T3?, T4?, T5?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), }, default(Type), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6>(string module, string name, Action<T1?, T2?, T3?, T4?, T5?, T6?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), }, default(Type), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7>(string module, string name, Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), }, default(Type), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8>(string module, string name, Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), }, default(Type), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string module, string name, Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), }, default(Type), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string module, string name, Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), }, default(Type), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string module, string name, Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), }, default(Type), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string module, string name, Action<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), }, default(Type), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]),
                            convT12.Unbox(storeContext, store, args_and_results[11]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult>(string module, string name, Func<TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(Array.Empty<Type>(), typeof(TResult), allowCaller: false, allowTuple: true);
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            );

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult>(string module, string name, Func<T?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT = ValueRaw.Converter<T>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT.Unbox(storeContext, store, args_and_results[0]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult>(string module, string name, Func<T1?, T2?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult>(string module, string name, Func<T1?, T2?, T3?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult>(string module, string name, Func<T1?, T2?, T3?, T4?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), }, typeof(TResult), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]),
                            convT12.Unbox(storeContext, store, args_and_results[11]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2>(string module, string name, Func<ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(Array.Empty<Type>(), typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            );

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2>(string module, string name, Func<T?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT = ValueRaw.Converter<T>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT.Unbox(storeContext, store, args_and_results[0]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2>(string module, string name, Func<T1?, T2?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2>(string module, string name, Func<T1?, T2?, T3?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2>(string module, string name, Func<T1?, T2?, T3?, T4?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]),
                            convT12.Unbox(storeContext, store, args_and_results[11]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2, TResult3>(string module, string name, Func<ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(Array.Empty<Type>(), typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            );

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2, TResult3>(string module, string name, Func<T?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT = ValueRaw.Converter<T>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT.Unbox(storeContext, store, args_and_results[0]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2, TResult3>(string module, string name, Func<T1?, T2?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2, TResult3>(string module, string name, Func<T1?, T2?, T3?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2, TResult3>(string module, string name, Func<T1?, T2?, T3?, T4?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2, TResult3>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2, TResult3>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2, TResult3>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2, TResult3>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2, TResult3>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2, TResult3>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2, TResult3>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2, TResult3>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]),
                            convT12.Unbox(storeContext, store, args_and_results[11]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(Array.Empty<Type>(), typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            );

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT = ValueRaw.Converter<T>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT.Unbox(storeContext, store, args_and_results[0]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1?, T2?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1?, T2?, T3?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1?, T2?, T3?, T4?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2, TResult3, TResult4>(string module, string name, Func<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: false, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]),
                            convT12.Unbox(storeContext, store, args_and_results[11]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction(string module, string name, CallerAction callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), }, default(Type), allowCaller: true, allowTuple: true);

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller);

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T>(string module, string name, CallerAction<T?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T), }, default(Type), allowCaller: true, allowTuple: true);
            var convT = ValueRaw.Converter<T>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT.Unbox(storeContext, store, args_and_results[0]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2>(string module, string name, CallerAction<T1?, T2?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), }, default(Type), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3>(string module, string name, CallerAction<T1?, T2?, T3?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), }, default(Type), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4>(string module, string name, CallerAction<T1?, T2?, T3?, T4?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), }, default(Type), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5>(string module, string name, CallerAction<T1?, T2?, T3?, T4?, T5?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), }, default(Type), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6>(string module, string name, CallerAction<T1?, T2?, T3?, T4?, T5?, T6?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), }, default(Type), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7>(string module, string name, CallerAction<T1?, T2?, T3?, T4?, T5?, T6?, T7?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), }, default(Type), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8>(string module, string name, CallerAction<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), }, default(Type), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9>(string module, string name, CallerAction<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), }, default(Type), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(string module, string name, CallerAction<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), }, default(Type), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(string module, string name, CallerAction<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), }, default(Type), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(string module, string name, CallerAction<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), }, default(Type), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]),
                            convT12.Unbox(storeContext, store, args_and_results[11]));

                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult>(string module, string name, CallerFunc<TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller);

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult>(string module, string name, CallerFunc<T?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT = ValueRaw.Converter<T>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT.Unbox(storeContext, store, args_and_results[0]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult>(string module, string name, CallerFunc<T1?, T2?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult>(string module, string name, CallerFunc<T1?, T2?, T3?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, TResult> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), }, typeof(TResult), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convTResult = ValueRaw.Converter<TResult>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]),
                            convT12.Unbox(storeContext, store, args_and_results[11]));

                        convTResult.Box(storeContext, store, ref args_and_results[0], result);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2>(string module, string name, CallerFunc<ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller);

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2>(string module, string name, CallerFunc<T?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT = ValueRaw.Converter<T>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT.Unbox(storeContext, store, args_and_results[0]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2>(string module, string name, CallerFunc<T1?, T2?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2>(string module, string name, CallerFunc<T1?, T2?, T3?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, ValueTuple<TResult1, TResult2>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), }, typeof(ValueTuple<TResult1, TResult2>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]),
                            convT12.Unbox(storeContext, store, args_and_results[11]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2, TResult3>(string module, string name, CallerFunc<ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller);

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT = ValueRaw.Converter<T>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT.Unbox(storeContext, store, args_and_results[0]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T1?, T2?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T1?, T2?, T3?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2, TResult3>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, ValueTuple<TResult1, TResult2, TResult3>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), }, typeof(ValueTuple<TResult1, TResult2, TResult3>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]),
                            convT12.Unbox(storeContext, store, args_and_results[11]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller);

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT = ValueRaw.Converter<T>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT.Unbox(storeContext, store, args_and_results[0]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T1?, T2?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T1?, T2?, T3?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

        /// <summary>
        /// Defines a function in the linker.
        /// </summary>
        /// <remarks>Functions defined with this method are store-independent.</remarks>
        /// <param name="module">The module name of the function.</param>
        /// <param name="name">The name of the function.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public void DefineFunction<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult1, TResult2, TResult3, TResult4>(string module, string name, CallerFunc<T1?, T2?, T3?, T4?, T5?, T6?, T7?, T8?, T9?, T10?, T11?, T12?, ValueTuple<TResult1, TResult2, TResult3, TResult4>> callback)
        {
            if (module is null)
            {
                throw new ArgumentNullException(nameof(module));
            }

            if (name is null)
            {
                throw new ArgumentNullException(nameof(name));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var (parameterKinds, resultKinds) = Function.GetFunctionType(new Type[] { typeof(Caller), typeof(T1), typeof(T2), typeof(T3), typeof(T4), typeof(T5), typeof(T6), typeof(T7), typeof(T8), typeof(T9), typeof(T10), typeof(T11), typeof(T12), }, typeof(ValueTuple<TResult1, TResult2, TResult3, TResult4>), allowCaller: true, allowTuple: true);
            var convT1 = ValueRaw.Converter<T1>();
            var convT2 = ValueRaw.Converter<T2>();
            var convT3 = ValueRaw.Converter<T3>();
            var convT4 = ValueRaw.Converter<T4>();
            var convT5 = ValueRaw.Converter<T5>();
            var convT6 = ValueRaw.Converter<T6>();
            var convT7 = ValueRaw.Converter<T7>();
            var convT8 = ValueRaw.Converter<T8>();
            var convT9 = ValueRaw.Converter<T9>();
            var convT10 = ValueRaw.Converter<T10>();
            var convT11 = ValueRaw.Converter<T11>();
            var convT12 = ValueRaw.Converter<T12>();
            var convTResult1 = ValueRaw.Converter<TResult1>();
            var convTResult2 = ValueRaw.Converter<TResult2>();
            var convTResult3 = ValueRaw.Converter<TResult3>();
            var convTResult4 = ValueRaw.Converter<TResult4>();

            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
                    try
                    {
                        var caller = new Caller(callerPtr);
                        var storeContext = caller.context;
                        var store = caller.store;

                        var result = callback(
                            caller,
                            convT1.Unbox(storeContext, store, args_and_results[0]),
                            convT2.Unbox(storeContext, store, args_and_results[1]),
                            convT3.Unbox(storeContext, store, args_and_results[2]),
                            convT4.Unbox(storeContext, store, args_and_results[3]),
                            convT5.Unbox(storeContext, store, args_and_results[4]),
                            convT6.Unbox(storeContext, store, args_and_results[5]),
                            convT7.Unbox(storeContext, store, args_and_results[6]),
                            convT8.Unbox(storeContext, store, args_and_results[7]),
                            convT9.Unbox(storeContext, store, args_and_results[8]),
                            convT10.Unbox(storeContext, store, args_and_results[9]),
                            convT11.Unbox(storeContext, store, args_and_results[10]),
                            convT12.Unbox(storeContext, store, args_and_results[11]));

                        convTResult1.Box(storeContext, store, ref args_and_results[0], result.Item1);
                        convTResult2.Box(storeContext, store, ref args_and_results[1], result.Item2);
                        convTResult3.Box(storeContext, store, ref args_and_results[2], result.Item3);
                        convTResult4.Box(storeContext, store, ref args_and_results[3], result.Item4);
                        
                        return IntPtr.Zero;
                    }
                    catch (Exception ex)
                    {
                        return Function.HandleCallbackException(ex);
                    }
                };

                const int StackallocThreshold = 256;

                byte[]? moduleBytesBuffer = null;
                var moduleLength = Encoding.UTF8.GetByteCount(module);
                Span<byte> moduleBytes = moduleLength <= StackallocThreshold ? stackalloc byte[moduleLength] : (moduleBytesBuffer = ArrayPool<byte>.Shared.Rent(moduleLength)).AsSpan()[..moduleLength];
                Encoding.UTF8.GetBytes(module, moduleBytes);

                byte[]? nameBytesBuffer = null;
                var nameLength = Encoding.UTF8.GetByteCount(name);
                Span<byte> nameBytes = nameLength <= StackallocThreshold ? stackalloc byte[nameLength] : (nameBytesBuffer = ArrayPool<byte>.Shared.Rent(nameLength)).AsSpan()[..nameLength];
                Encoding.UTF8.GetBytes(name, nameBytes);

                var funcType = Function.CreateFunctionType(parameterKinds, resultKinds);
                try
                {
                    fixed (byte* modulePtr = moduleBytes, namePtr = nameBytes)
                    {
                        var error = Native.wasmtime_linker_define_func_unchecked(
                            handle,
                            modulePtr,
                            (nuint)moduleBytes.Length,
                            namePtr,
                            (nuint)nameBytes.Length,
                            funcType,
                            func,
                            GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                            Function.Finalizer
                        );

                        if (error != IntPtr.Zero)
                        {
                            throw WasmtimeException.FromOwnedError(error);
                        }
                    }
                }
                finally
                {
                    Function.Native.wasm_functype_delete(funcType);

                    if (moduleBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(moduleBytesBuffer);
                    }
                    if (nameBytesBuffer is not null)
                    {
                        ArrayPool<byte>.Shared.Return(nameBytesBuffer);
                    }
                }
            }
        }

    }
}