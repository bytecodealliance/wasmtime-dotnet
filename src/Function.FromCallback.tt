<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" encoding="us-ascii" #>
<#@ include file="FunctionCallbackOverloadTemplates.t4" once="true" #>
<#
// Note: We specify ASCII as output encoding above to prevent different UTF-8 BOM behavior with VS and dotnet-t4.
#>
// <auto-generated>
// This file is automatically generated from a T4 text template (Function.FromCallback.tt)
// when building the project.
// Do not modify it directly.
// </auto-generated>

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;

namespace Wasmtime
{
    public partial class Function
    {
<#
// Generate overloads for different combinations of function parameter count, result count,
// and hasCaller states.
// Currently, we generate them for a maximum of 12 parameters and 4 result values, which means there
// will be 2 * 13 * 5 = 130 overloads of DefineFunction accepting an Action/Func.
// Note that more than 200 overloads can cause the C# compiler to no longer resolve the overloads
// correctly (tested with Visual Studio 17.4.0 Preview 2.1).
// For delegate types not covered by these overloads, we have a method accepting a Delegate which
// will be called using reflection.
foreach (var (hasCaller, resultCount, parameterCount, methodGenerics, delegateType, callbackParameterTypeExpressions, callbackReturnTypeExpression, parameterConverters, resultConverters, converterRequiresStoreCode) in EnumerateTypeCombinations())
{
#>
        /// <summary>
        /// Creates a function given a callback.
        /// </summary>
        /// <param name="store">The store to create the function in.</param>
        /// <param name="callback">The callback for when the function is invoked.</param>
        public static Function FromCallback<#= methodGenerics #>(IStore store, <#= delegateType #> callback)
        {
            if (store is null)
            {
                throw new ArgumentNullException(nameof(store));
            }

            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            var parameterKinds = new List<ValueKind>();
            var resultKinds = new List<ValueKind>();

            <# if (callbackParameterTypeExpressions.Length == 0) { #>
            var callbackParameterTypes = Array.Empty<Type>();
            <# } else { #>
            var callbackParameterTypes = new Type[] { <#= callbackParameterTypeExpressions #>};
            <# } #>

            var callbackReturnType = <#= callbackReturnTypeExpression #>;

            using var funcType = Function.GetFunctionType(callbackParameterTypes, callbackReturnType, parameterKinds, resultKinds, allowCaller: <#= hasCaller ? "true" : "false" #>, allowTuple: <#= (resultCount > 1) ? "true" : "false" #>, out _, out _);

            if (funcType is null)
            {
                // This means a parameter/result type combination was used that cannot
                // be represented with the current generic parameters. Therefore, fall
                // back to using reflection.
                return FromCallback(store, (Delegate)callback);
            }

<#= parameterConverters
#><#= resultConverters
#><#= converterRequiresStoreCode
#>
            unsafe
            {
                Function.Native.WasmtimeFuncUncheckedCallback func = (env, callerPtr, args_and_results, num_args_and_results) =>
                {
<# GenerateCallbackContent(hasCaller, resultCount, parameterCount); #>
                };

                Native.wasmtime_func_new_unchecked(
                    store.Context.handle,
                    funcType,
                    func,
                    GCHandle.ToIntPtr(GCHandle.Alloc(func)),
                    Finalizer,
                    out var externFunc
                );

                GC.KeepAlive(store);

                return new Function(store, externFunc, parameterKinds, resultKinds);
            }
        }

<#
}
#>
    }
}