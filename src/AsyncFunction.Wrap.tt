<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" encoding="us-ascii" #>
<#@ include file="FunctionCallbackOverloadTemplates.t4" once="true" #>
<#
// Note: We specify ASCII as output encoding above to prevent different UTF-8 BOM behavior with VS and dotnet-t4.
#>
// <auto-generated>
// This file is automatically generated from a T4 text template (Function.Wrap.tt)
// when building the project.
// Do not modify it directly.
// </auto-generated>

#nullable enable

using System;
using System.Buffers;

namespace Wasmtime
{
    public partial class AsyncFunction
    {
        private object? _wrapperCache;

<#
// Generate overloads of WrapAction/WrapFunc for up to 12 parameters and up to one return type
// (2 * 17 overloads).
// Note: We only use up to one return type parameter here, because unlike e.g.
// Function.FromCallback() which explicitely declares ValueTuple<...> overloads, here we
// expect that the single return type parameter is implicitely used as ValueTuple<...> for
// the return type factory.
foreach (var (_, returnTypeCount, parameterCount, methodGenerics, delegateType, callbackParameterTypeExpressions, callbackReturnTypeExpression, parameterConverters, _) in EnumerateTypeCombinations(12, 1, canHaveCaller: false, delegateInputsNullable: false, async:true))
{
#>
        /// <summary>
        /// Attempt to wrap this function as <#= returnTypeCount > 0 ? "a <c>Func</c>" : "an <c>Action</c>" #>. Wrapped <c><#= returnTypeCount > 0 ? "Func" : "Action" #></c> is faster than a normal Invoke call.
        /// </summary>
        /// <returns>A <c><#= returnTypeCount > 0 ? "Func" : "Action" #></c> to invoke this function, or <c>null</c> if the type signature is incompatible.</returns>
        public <#= delegateType #>? Wrap<#= returnTypeCount > 0 ? "Func" : "Action" #><#= methodGenerics #>()
        {
            if (store is null || IsNull)
            {
                throw new InvalidOperationException("Cannot wrap a null function reference.");
            }

            // Try to retrieve it from the cache. if it's cached it must have passed the type
            // signature check already, so it's safe to do this before CheckTypeSignature.
            if (_wrapperCache?.GetType() == typeof(<#= delegateType #>))
            {
                return (<#= delegateType #>)_wrapperCache;
            }

            // Check that the requested type signature is compatible
            <# if (callbackParameterTypeExpressions.Length == 0) { #>
var parameterTypes = Array.Empty<Type>();
            <# } else { #>
var parameterTypes = new Type[] { <#= callbackParameterTypeExpressions #>};
            <# } #>

            // Check if the requested type signature is compatible with the function being wrapped
            if (!CheckTypeSignature(<#= callbackReturnTypeExpression #>, parameterTypes))
            {
                return null;
            }

            // Fetch a converter for each parameter type to box it
<#= parameterConverters #>
<#
    if (returnTypeCount > 0)
    { 
#>
            // Create a factory for the return type
            var factory = ReturnTypeFactory<TResult>.Create();

<# 
    } 
#>
            // Determine how much space to allocate for params/results
            var allocCount = <#= parameterCount.ToString(CultureInfo.InvariantCulture) #> + Results.Count;

            <#= delegateType #> result = async (<#
    for (int x = 0; x < parameterCount; x++)
    {
        if (x >= 1)
        {
            #>, <#
        }

        #>p<#= x.ToString(CultureInfo.InvariantCulture) #><#

    }
#>) =>
            {
                // Allocate space for both the arguments and the results.
                var argsAndResults = ArrayPool<Value>.Shared.Rent(allocCount);
                try
                {
<#
    for (int x = 0; x < parameterCount; x++)
    {
        string xStr = x.ToString(CultureInfo.InvariantCulture);
#>
                    argsAndResults[<#= xStr #>] = Value.FromValueBox(
                        convT<#= parameterCount is 1 ? "" : (x + 1).ToString(CultureInfo.InvariantCulture) #>.Box(p<#= xStr #>)
                    );
<#
    }

    if (returnTypeCount > 0)
    {
#>
                    return await InvokeWithReturn(argsAndResults, factory);
<#
    }
    else
    {
#>
                    await InvokeWithoutReturn(argsAndResults);
<#
    }
#>
                }
                finally
                {
                    ArrayPool<Value>.Shared.Return(argsAndResults);
                }
            };

            _wrapperCache = result;
            return result;
        }

<#
}
#>
    }
}


